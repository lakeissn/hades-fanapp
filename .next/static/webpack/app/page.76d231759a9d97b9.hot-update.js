"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Grainient.tsx":
/*!**********************************!*\
  !*** ./components/Grainient.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Renderer.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/extras/Triangle.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Program.js\");\n/* harmony import */ var ogl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ogl */ \"(app-pages-browser)/./node_modules/ogl/src/core/Mesh.js\");\n/* harmony import */ var _Grainient_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Grainient.css */ \"(app-pages-browser)/./components/Grainient.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst hexToRgb = (hex)=>{\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!result) return [\n        1,\n        1,\n        1\n    ];\n    return [\n        parseInt(result[1], 16) / 255,\n        parseInt(result[2], 16) / 255,\n        parseInt(result[3], 16) / 255\n    ];\n};\nconst vertex = \"#version 300 es\\nin vec2 position;\\nvoid main() {\\n  gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\";\nconst fragment = \"#version 300 es\\nprecision highp float;\\nuniform vec2 iResolution;\\nuniform float iTime;\\nuniform float uTimeSpeed;\\nuniform float uColorBalance;\\nuniform float uWarpStrength;\\nuniform float uWarpFrequency;\\nuniform float uWarpSpeed;\\nuniform float uWarpAmplitude;\\nuniform float uBlendAngle;\\nuniform float uBlendSoftness;\\nuniform float uRotationAmount;\\nuniform float uNoiseScale;\\nuniform float uGrainAmount;\\nuniform float uGrainScale;\\nuniform float uGrainAnimated;\\nuniform float uContrast;\\nuniform float uGamma;\\nuniform float uSaturation;\\nuniform vec2 uCenterOffset;\\nuniform float uZoom;\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\nuniform vec3 uColor3;\\nout vec4 fragColor;\\n#define S(a,b,t) smoothstep(a,b,t)\\nmat2 Rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);} \\nvec2 hash(vec2 p){p=vec2(dot(p,vec2(2127.1,81.17)),dot(p,vec2(1269.5,283.37)));return fract(sin(p)*43758.5453);} \\nfloat noise(vec2 p){vec2 i=floor(p),f=fract(p),u=f*f*(3.0-2.0*f);float n=mix(mix(dot(-1.0+2.0*hash(i+vec2(0.0,0.0)),f-vec2(0.0,0.0)),dot(-1.0+2.0*hash(i+vec2(1.0,0.0)),f-vec2(1.0,0.0)),u.x),mix(dot(-1.0+2.0*hash(i+vec2(0.0,1.0)),f-vec2(0.0,1.0)),dot(-1.0+2.0*hash(i+vec2(1.0,1.0)),f-vec2(1.0,1.0)),u.x),u.y);return 0.5+0.5*n;}\\nvoid mainImage(out vec4 o, vec2 C){\\n  float t=iTime*uTimeSpeed;\\n  vec2 uv=C/iResolution.xy;\\n  float ratio=iResolution.x/iResolution.y;\\n  vec2 tuv=uv-0.5+uCenterOffset;\\n  tuv/=max(uZoom,0.001);\\n\\n  float degree=noise(vec2(t*0.1,tuv.x*tuv.y)*uNoiseScale);\\n  tuv.y*=1.0/ratio;\\n  tuv*=Rot(radians((degree-0.5)*uRotationAmount+180.0));\\n  tuv.y*=ratio;\\n\\n  float frequency=uWarpFrequency;\\n  float ws=max(uWarpStrength,0.001);\\n  float amplitude=uWarpAmplitude/ws;\\n  float warpTime=t*uWarpSpeed;\\n  tuv.x+=sin(tuv.y*frequency+warpTime)/amplitude;\\n  tuv.y+=sin(tuv.x*(frequency*1.5)+warpTime)/(amplitude*0.5);\\n\\n  vec3 colLav=uColor1;\\n  vec3 colOrg=uColor2;\\n  vec3 colDark=uColor3;\\n  float b=uColorBalance;\\n  float s=max(uBlendSoftness,0.0);\\n  mat2 blendRot=Rot(radians(uBlendAngle));\\n  float blendX=(tuv*blendRot).x;\\n  float edge0=-0.3-b-s;\\n  float edge1=0.2-b+s;\\n  float v0=0.5-b+s;\\n  float v1=-0.3-b-s;\\n  vec3 layer1=mix(colDark,colOrg,S(edge0,edge1,blendX));\\n  vec3 layer2=mix(colOrg,colLav,S(edge0,edge1,blendX));\\n  vec3 col=mix(layer1,layer2,S(v0,v1,tuv.y));\\n\\n  vec2 grainUv=uv*max(uGrainScale,0.001);\\n  if(uGrainAnimated>0.5){grainUv+=vec2(iTime*0.05);} \\n  float grain=fract(sin(dot(grainUv,vec2(12.9898,78.233)))*43758.5453);\\n  col+=(grain-0.5)*uGrainAmount;\\n\\n  col=(col-0.5)*uContrast+0.5;\\n  float luma=dot(col,vec3(0.2126,0.7152,0.0722));\\n  col=mix(vec3(luma),col,uSaturation);\\n  col=pow(max(col,0.0),vec3(1.0/max(uGamma,0.001)));\\n  col=clamp(col,0.0,1.0);\\n\\n  o=vec4(col,1.0);\\n}\\nvoid main(){\\n  vec4 o=vec4(0.0);\\n  mainImage(o,gl_FragCoord.xy);\\n  fragColor=o;\\n}\\n\";\nconst Grainient = (param)=>{\n    let { timeSpeed = 0.25, colorBalance = 0.0, warpStrength = 1.0, warpFrequency = 5.0, warpSpeed = 2.0, warpAmplitude = 50.0, blendAngle = 0.0, blendSoftness = 0.05, rotationAmount = 500.0, noiseScale = 2.0, grainAmount = 0.1, grainScale = 2.0, grainAnimated = false, contrast = 1.5, gamma = 1.0, saturation = 1.0, centerX = 0.0, centerY = 0.0, zoom = 0.9, color1 = \"#98E698\", color2 = \"#22c55e\", color3 = \"#166534\", className = \"\" } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!containerRef.current) return;\n        const renderer = new ogl__WEBPACK_IMPORTED_MODULE_3__.Renderer({\n            webgl: 2,\n            alpha: true,\n            antialias: true,\n            dpr: Math.min(window.devicePixelRatio || 1, 2)\n        });\n        const gl = renderer.gl;\n        const [r, g, b] = hexToRgb(color1);\n        gl.clearColor(r, g, b, 1);\n        const canvas = gl.canvas;\n        canvas.style.width = \"100%\";\n        canvas.style.height = \"100%\";\n        canvas.style.display = \"block\";\n        const container = containerRef.current;\n        container.appendChild(canvas);\n        const geometry = new ogl__WEBPACK_IMPORTED_MODULE_4__.Triangle(gl);\n        const program = new ogl__WEBPACK_IMPORTED_MODULE_5__.Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                iTime: {\n                    value: 0\n                },\n                iResolution: {\n                    value: new Float32Array([\n                        1,\n                        1\n                    ])\n                },\n                uTimeSpeed: {\n                    value: timeSpeed\n                },\n                uColorBalance: {\n                    value: colorBalance\n                },\n                uWarpStrength: {\n                    value: warpStrength\n                },\n                uWarpFrequency: {\n                    value: warpFrequency\n                },\n                uWarpSpeed: {\n                    value: warpSpeed\n                },\n                uWarpAmplitude: {\n                    value: warpAmplitude\n                },\n                uBlendAngle: {\n                    value: blendAngle\n                },\n                uBlendSoftness: {\n                    value: blendSoftness\n                },\n                uRotationAmount: {\n                    value: rotationAmount\n                },\n                uNoiseScale: {\n                    value: noiseScale\n                },\n                uGrainAmount: {\n                    value: grainAmount\n                },\n                uGrainScale: {\n                    value: grainScale\n                },\n                uGrainAnimated: {\n                    value: grainAnimated ? 1.0 : 0.0\n                },\n                uContrast: {\n                    value: contrast\n                },\n                uGamma: {\n                    value: gamma\n                },\n                uSaturation: {\n                    value: saturation\n                },\n                uCenterOffset: {\n                    value: new Float32Array([\n                        centerX,\n                        centerY\n                    ])\n                },\n                uZoom: {\n                    value: zoom\n                },\n                uColor1: {\n                    value: new Float32Array(hexToRgb(color1))\n                },\n                uColor2: {\n                    value: new Float32Array(hexToRgb(color2))\n                },\n                uColor3: {\n                    value: new Float32Array(hexToRgb(color3))\n                }\n            }\n        });\n        const mesh = new ogl__WEBPACK_IMPORTED_MODULE_6__.Mesh(gl, {\n            geometry,\n            program\n        });\n        const setSize = ()=>{\n            const rect = container.getBoundingClientRect();\n            const width = Math.max(1, Math.floor(rect.width));\n            const height = Math.max(1, Math.floor(rect.height));\n            renderer.setSize(width, height);\n            const res = program.uniforms.iResolution.value;\n            res[0] = gl.drawingBufferWidth;\n            res[1] = gl.drawingBufferHeight;\n        };\n        const ro = new ResizeObserver(setSize);\n        ro.observe(container);\n        setSize();\n        let raf = 0;\n        const t0 = performance.now();\n        const loop = (t)=>{\n            program.uniforms.iTime.value = (t - t0) * 0.001;\n            renderer.render({\n                scene: mesh\n            });\n            raf = requestAnimationFrame(loop);\n        };\n        raf = requestAnimationFrame(loop);\n        return ()=>{\n            cancelAnimationFrame(raf);\n            ro.disconnect();\n            try {\n                container.removeChild(canvas);\n            } catch (e) {\n            // Ignore\n            }\n        };\n    }, [\n        timeSpeed,\n        colorBalance,\n        warpStrength,\n        warpFrequency,\n        warpSpeed,\n        warpAmplitude,\n        blendAngle,\n        blendSoftness,\n        rotationAmount,\n        noiseScale,\n        grainAmount,\n        grainScale,\n        grainAnimated,\n        contrast,\n        gamma,\n        saturation,\n        centerX,\n        centerY,\n        zoom,\n        color1,\n        color2,\n        color3\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"grainient-container \".concat(className).trim()\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\pyosh\\\\OneDrive\\\\바탕 화면\\\\hades-fanapp\\\\components\\\\Grainient.tsx\",\n        lineNumber: 269,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Grainient, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = Grainient;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Grainient);\nvar _c;\n$RefreshReg$(_c, \"Grainient\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvR3JhaW5pZW50LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUVpRDtBQUNPO0FBQy9CO0FBNEJ6QixNQUFNTyxXQUFXLENBQUNDO0lBQ2hCLE1BQU1DLFNBQVMsNENBQTRDQyxJQUFJLENBQUNGO0lBQ2hFLElBQUksQ0FBQ0MsUUFBUSxPQUFPO1FBQUM7UUFBRztRQUFHO0tBQUU7SUFDN0IsT0FBTztRQUFDRSxTQUFTRixNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU07UUFBS0UsU0FBU0YsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNO1FBQUtFLFNBQVNGLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTTtLQUFJO0FBQ3RHO0FBRUEsTUFBTUcsU0FBVTtBQU9oQixNQUFNQyxXQUFZO0FBb0ZsQixNQUFNQyxZQUFzQztRQUFDLEVBQzNDQyxZQUFZLElBQUksRUFDaEJDLGVBQWUsR0FBRyxFQUNsQkMsZUFBZSxHQUFHLEVBQ2xCQyxnQkFBZ0IsR0FBRyxFQUNuQkMsWUFBWSxHQUFHLEVBQ2ZDLGdCQUFnQixJQUFJLEVBQ3BCQyxhQUFhLEdBQUcsRUFDaEJDLGdCQUFnQixJQUFJLEVBQ3BCQyxpQkFBaUIsS0FBSyxFQUN0QkMsYUFBYSxHQUFHLEVBQ2hCQyxjQUFjLEdBQUcsRUFDakJDLGFBQWEsR0FBRyxFQUNoQkMsZ0JBQWdCLEtBQUssRUFDckJDLFdBQVcsR0FBRyxFQUNkQyxRQUFRLEdBQUcsRUFDWEMsYUFBYSxHQUFHLEVBQ2hCQyxVQUFVLEdBQUcsRUFDYkMsVUFBVSxHQUFHLEVBQ2JDLE9BQU8sR0FBRyxFQUNWQyxTQUFTLFNBQVMsRUFDbEJDLFNBQVMsU0FBUyxFQUNsQkMsU0FBUyxTQUFTLEVBQ2xCQyxZQUFZLEVBQUUsRUFDZjs7SUFDQyxNQUFNQyxlQUFlcEMsNkNBQU1BLENBQXdCO0lBRW5ERCxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ3FDLGFBQWFDLE9BQU8sRUFBRTtRQUUzQixNQUFN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QzNFOEIsR0FBRyxDQUFDLEVBQUUsR0FBRzlDLEdBQUcrQyxrQkFBa0I7WUFDOUJELEdBQUcsQ0FBQyxFQUFFLEdBQUc5QyxHQUFHZ0QsbUJBQW1CO1FBQ2pDO1FBRUEsTUFBTUMsS0FBSyxJQUFJQyxlQUFlVDtRQUM5QlEsR0FBR0UsT0FBTyxDQUFDekM7UUFDWCtCO1FBRUEsSUFBSVcsTUFBTTtRQUNWLE1BQU1DLEtBQUtDLFlBQVlDLEdBQUc7UUFDMUIsTUFBTUMsT0FBTyxDQUFDQztZQUNYNUMsUUFBUUMsUUFBUSxDQUFDQyxLQUFLLENBQXVCQyxLQUFLLEdBQUcsQ0FBQ3lDLElBQUlKLEVBQUMsSUFBSztZQUNqRTlELFNBQVNtRSxNQUFNLENBQUM7Z0JBQUVDLE9BQU9uQjtZQUFLO1lBQzlCWSxNQUFNUSxzQkFBc0JKO1FBQzlCO1FBQ0FKLE1BQU1RLHNCQUFzQko7UUFFNUIsT0FBTztZQUNMSyxxQkFBcUJUO1lBQ3JCSCxHQUFHYSxVQUFVO1lBQ2IsSUFBSTtnQkFDRnBELFVBQVVxRCxXQUFXLENBQUMxRDtZQUN4QixFQUFFLFVBQU07WUFDTixTQUFTO1lBQ1g7UUFDRjtJQUNGLEdBQUc7UUFDRHZDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO0tBQ0Q7SUFFRCxxQkFBTyw4REFBQzZFO1FBQUlDLEtBQUs1RTtRQUFjRCxXQUFXLHVCQUFpQyxPQUFWQSxXQUFZOEUsSUFBSTs7Ozs7O0FBQ25GO0dBNUlNckc7S0FBQUE7QUE4SU4sK0RBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9HcmFpbmllbnQudHN4PzRiNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgUmVuZGVyZXIsIFByb2dyYW0sIE1lc2gsIFRyaWFuZ2xlIH0gZnJvbSBcIm9nbFwiO1xyXG5pbXBvcnQgXCIuL0dyYWluaWVudC5jc3NcIjtcclxuXHJcbmludGVyZmFjZSBHcmFpbmllbnRQcm9wcyB7XHJcbiAgdGltZVNwZWVkPzogbnVtYmVyO1xyXG4gIGNvbG9yQmFsYW5jZT86IG51bWJlcjtcclxuICB3YXJwU3RyZW5ndGg/OiBudW1iZXI7XHJcbiAgd2FycEZyZXF1ZW5jeT86IG51bWJlcjtcclxuICB3YXJwU3BlZWQ/OiBudW1iZXI7XHJcbiAgd2FycEFtcGxpdHVkZT86IG51bWJlcjtcclxuICBibGVuZEFuZ2xlPzogbnVtYmVyO1xyXG4gIGJsZW5kU29mdG5lc3M/OiBudW1iZXI7XHJcbiAgcm90YXRpb25BbW91bnQ/OiBudW1iZXI7XHJcbiAgbm9pc2VTY2FsZT86IG51bWJlcjtcclxuICBncmFpbkFtb3VudD86IG51bWJlcjtcclxuICBncmFpblNjYWxlPzogbnVtYmVyO1xyXG4gIGdyYWluQW5pbWF0ZWQ/OiBib29sZWFuO1xyXG4gIGNvbnRyYXN0PzogbnVtYmVyO1xyXG4gIGdhbW1hPzogbnVtYmVyO1xyXG4gIHNhdHVyYXRpb24/OiBudW1iZXI7XHJcbiAgY2VudGVyWD86IG51bWJlcjtcclxuICBjZW50ZXJZPzogbnVtYmVyO1xyXG4gIHpvb20/OiBudW1iZXI7XHJcbiAgY29sb3IxPzogc3RyaW5nO1xyXG4gIGNvbG9yMj86IHN0cmluZztcclxuICBjb2xvcjM/OiBzdHJpbmc7XHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBoZXhUb1JnYiA9IChoZXg6IHN0cmluZyk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9PiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XHJcbiAgaWYgKCFyZXN1bHQpIHJldHVybiBbMSwgMSwgMV07XHJcbiAgcmV0dXJuIFtwYXJzZUludChyZXN1bHRbMV0sIDE2KSAvIDI1NSwgcGFyc2VJbnQocmVzdWx0WzJdLCAxNikgLyAyNTUsIHBhcnNlSW50KHJlc3VsdFszXSwgMTYpIC8gMjU1XTtcclxufTtcclxuXHJcbmNvbnN0IHZlcnRleCA9IGAjdmVyc2lvbiAzMDAgZXNcclxuaW4gdmVjMiBwb3NpdGlvbjtcclxudm9pZCBtYWluKCkge1xyXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xyXG59XHJcbmA7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IGAjdmVyc2lvbiAzMDAgZXNcclxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG51bmlmb3JtIHZlYzIgaVJlc29sdXRpb247XHJcbnVuaWZvcm0gZmxvYXQgaVRpbWU7XHJcbnVuaWZvcm0gZmxvYXQgdVRpbWVTcGVlZDtcclxudW5pZm9ybSBmbG9hdCB1Q29sb3JCYWxhbmNlO1xyXG51bmlmb3JtIGZsb2F0IHVXYXJwU3RyZW5ndGg7XHJcbnVuaWZvcm0gZmxvYXQgdVdhcnBGcmVxdWVuY3k7XHJcbnVuaWZvcm0gZmxvYXQgdVdhcnBTcGVlZDtcclxudW5pZm9ybSBmbG9hdCB1V2FycEFtcGxpdHVkZTtcclxudW5pZm9ybSBmbG9hdCB1QmxlbmRBbmdsZTtcclxudW5pZm9ybSBmbG9hdCB1QmxlbmRTb2Z0bmVzcztcclxudW5pZm9ybSBmbG9hdCB1Um90YXRpb25BbW91bnQ7XHJcbnVuaWZvcm0gZmxvYXQgdU5vaXNlU2NhbGU7XHJcbnVuaWZvcm0gZmxvYXQgdUdyYWluQW1vdW50O1xyXG51bmlmb3JtIGZsb2F0IHVHcmFpblNjYWxlO1xyXG51bmlmb3JtIGZsb2F0IHVHcmFpbkFuaW1hdGVkO1xyXG51bmlmb3JtIGZsb2F0IHVDb250cmFzdDtcclxudW5pZm9ybSBmbG9hdCB1R2FtbWE7XHJcbnVuaWZvcm0gZmxvYXQgdVNhdHVyYXRpb247XHJcbnVuaWZvcm0gdmVjMiB1Q2VudGVyT2Zmc2V0O1xyXG51bmlmb3JtIGZsb2F0IHVab29tO1xyXG51bmlmb3JtIHZlYzMgdUNvbG9yMTtcclxudW5pZm9ybSB2ZWMzIHVDb2xvcjI7XHJcbnVuaWZvcm0gdmVjMyB1Q29sb3IzO1xyXG5vdXQgdmVjNCBmcmFnQ29sb3I7XHJcbiNkZWZpbmUgUyhhLGIsdCkgc21vb3Roc3RlcChhLGIsdClcclxubWF0MiBSb3QoZmxvYXQgYSl7ZmxvYXQgcz1zaW4oYSksYz1jb3MoYSk7cmV0dXJuIG1hdDIoYywtcyxzLGMpO30gXHJcbnZlYzIgaGFzaCh2ZWMyIHApe3A9dmVjMihkb3QocCx2ZWMyKDIxMjcuMSw4MS4xNykpLGRvdChwLHZlYzIoMTI2OS41LDI4My4zNykpKTtyZXR1cm4gZnJhY3Qoc2luKHApKjQzNzU4LjU0NTMpO30gXHJcbmZsb2F0IG5vaXNlKHZlYzIgcCl7dmVjMiBpPWZsb29yKHApLGY9ZnJhY3QocCksdT1mKmYqKDMuMC0yLjAqZik7ZmxvYXQgbj1taXgobWl4KGRvdCgtMS4wKzIuMCpoYXNoKGkrdmVjMigwLjAsMC4wKSksZi12ZWMyKDAuMCwwLjApKSxkb3QoLTEuMCsyLjAqaGFzaChpK3ZlYzIoMS4wLDAuMCkpLGYtdmVjMigxLjAsMC4wKSksdS54KSxtaXgoZG90KC0xLjArMi4wKmhhc2goaSt2ZWMyKDAuMCwxLjApKSxmLXZlYzIoMC4wLDEuMCkpLGRvdCgtMS4wKzIuMCpoYXNoKGkrdmVjMigxLjAsMS4wKSksZi12ZWMyKDEuMCwxLjApKSx1LngpLHUueSk7cmV0dXJuIDAuNSswLjUqbjt9XHJcbnZvaWQgbWFpbkltYWdlKG91dCB2ZWM0IG8sIHZlYzIgQyl7XHJcbiAgZmxvYXQgdD1pVGltZSp1VGltZVNwZWVkO1xyXG4gIHZlYzIgdXY9Qy9pUmVzb2x1dGlvbi54eTtcclxuICBmbG9hdCByYXRpbz1pUmVzb2x1dGlvbi54L2lSZXNvbHV0aW9uLnk7XHJcbiAgdmVjMiB0dXY9dXYtMC41K3VDZW50ZXJPZmZzZXQ7XHJcbiAgdHV2Lz1tYXgodVpvb20sMC4wMDEpO1xyXG5cclxuICBmbG9hdCBkZWdyZWU9bm9pc2UodmVjMih0KjAuMSx0dXYueCp0dXYueSkqdU5vaXNlU2NhbGUpO1xyXG4gIHR1di55Kj0xLjAvcmF0aW87XHJcbiAgdHV2Kj1Sb3QocmFkaWFucygoZGVncmVlLTAuNSkqdVJvdGF0aW9uQW1vdW50KzE4MC4wKSk7XHJcbiAgdHV2LnkqPXJhdGlvO1xyXG5cclxuICBmbG9hdCBmcmVxdWVuY3k9dVdhcnBGcmVxdWVuY3k7XHJcbiAgZmxvYXQgd3M9bWF4KHVXYXJwU3RyZW5ndGgsMC4wMDEpO1xyXG4gIGZsb2F0IGFtcGxpdHVkZT11V2FycEFtcGxpdHVkZS93cztcclxuICBmbG9hdCB3YXJwVGltZT10KnVXYXJwU3BlZWQ7XHJcbiAgdHV2LngrPXNpbih0dXYueSpmcmVxdWVuY3krd2FycFRpbWUpL2FtcGxpdHVkZTtcclxuICB0dXYueSs9c2luKHR1di54KihmcmVxdWVuY3kqMS41KSt3YXJwVGltZSkvKGFtcGxpdHVkZSowLjUpO1xyXG5cclxuICB2ZWMzIGNvbExhdj11Q29sb3IxO1xyXG4gIHZlYzMgY29sT3JnPXVDb2xvcjI7XHJcbiAgdmVjMyBjb2xEYXJrPXVDb2xvcjM7XHJcbiAgZmxvYXQgYj11Q29sb3JCYWxhbmNlO1xyXG4gIGZsb2F0IHM9bWF4KHVCbGVuZFNvZnRuZXNzLDAuMCk7XHJcbiAgbWF0MiBibGVuZFJvdD1Sb3QocmFkaWFucyh1QmxlbmRBbmdsZSkpO1xyXG4gIGZsb2F0IGJsZW5kWD0odHV2KmJsZW5kUm90KS54O1xyXG4gIGZsb2F0IGVkZ2UwPS0wLjMtYi1zO1xyXG4gIGZsb2F0IGVkZ2UxPTAuMi1iK3M7XHJcbiAgZmxvYXQgdjA9MC41LWIrcztcclxuICBmbG9hdCB2MT0tMC4zLWItcztcclxuICB2ZWMzIGxheWVyMT1taXgoY29sRGFyayxjb2xPcmcsUyhlZGdlMCxlZGdlMSxibGVuZFgpKTtcclxuICB2ZWMzIGxheWVyMj1taXgoY29sT3JnLGNvbExhdixTKGVkZ2UwLGVkZ2UxLGJsZW5kWCkpO1xyXG4gIHZlYzMgY29sPW1peChsYXllcjEsbGF5ZXIyLFModjAsdjEsdHV2LnkpKTtcclxuXHJcbiAgdmVjMiBncmFpblV2PXV2Km1heCh1R3JhaW5TY2FsZSwwLjAwMSk7XHJcbiAgaWYodUdyYWluQW5pbWF0ZWQ+MC41KXtncmFpblV2Kz12ZWMyKGlUaW1lKjAuMDUpO30gXHJcbiAgZmxvYXQgZ3JhaW49ZnJhY3Qoc2luKGRvdChncmFpblV2LHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkqNDM3NTguNTQ1Myk7XHJcbiAgY29sKz0oZ3JhaW4tMC41KSp1R3JhaW5BbW91bnQ7XHJcblxyXG4gIGNvbD0oY29sLTAuNSkqdUNvbnRyYXN0KzAuNTtcclxuICBmbG9hdCBsdW1hPWRvdChjb2wsdmVjMygwLjIxMjYsMC43MTUyLDAuMDcyMikpO1xyXG4gIGNvbD1taXgodmVjMyhsdW1hKSxjb2wsdVNhdHVyYXRpb24pO1xyXG4gIGNvbD1wb3cobWF4KGNvbCwwLjApLHZlYzMoMS4wL21heCh1R2FtbWEsMC4wMDEpKSk7XHJcbiAgY29sPWNsYW1wKGNvbCwwLjAsMS4wKTtcclxuXHJcbiAgbz12ZWM0KGNvbCwxLjApO1xyXG59XHJcbnZvaWQgbWFpbigpe1xyXG4gIHZlYzQgbz12ZWM0KDAuMCk7XHJcbiAgbWFpbkltYWdlKG8sZ2xfRnJhZ0Nvb3JkLnh5KTtcclxuICBmcmFnQ29sb3I9bztcclxufVxyXG5gO1xyXG5cclxuY29uc3QgR3JhaW5pZW50OiBSZWFjdC5GQzxHcmFpbmllbnRQcm9wcz4gPSAoe1xyXG4gIHRpbWVTcGVlZCA9IDAuMjUsXHJcbiAgY29sb3JCYWxhbmNlID0gMC4wLFxyXG4gIHdhcnBTdHJlbmd0aCA9IDEuMCxcclxuICB3YXJwRnJlcXVlbmN5ID0gNS4wLFxyXG4gIHdhcnBTcGVlZCA9IDIuMCxcclxuICB3YXJwQW1wbGl0dWRlID0gNTAuMCxcclxuICBibGVuZEFuZ2xlID0gMC4wLFxyXG4gIGJsZW5kU29mdG5lc3MgPSAwLjA1LFxyXG4gIHJvdGF0aW9uQW1vdW50ID0gNTAwLjAsXHJcbiAgbm9pc2VTY2FsZSA9IDIuMCxcclxuICBncmFpbkFtb3VudCA9IDAuMSxcclxuICBncmFpblNjYWxlID0gMi4wLFxyXG4gIGdyYWluQW5pbWF0ZWQgPSBmYWxzZSxcclxuICBjb250cmFzdCA9IDEuNSxcclxuICBnYW1tYSA9IDEuMCxcclxuICBzYXR1cmF0aW9uID0gMS4wLFxyXG4gIGNlbnRlclggPSAwLjAsXHJcbiAgY2VudGVyWSA9IDAuMCxcclxuICB6b29tID0gMC45LFxyXG4gIGNvbG9yMSA9IFwiIzk4RTY5OFwiLFxyXG4gIGNvbG9yMiA9IFwiIzIyYzU1ZVwiLFxyXG4gIGNvbG9yMyA9IFwiIzE2NjUzNFwiLFxyXG4gIGNsYXNzTmFtZSA9IFwiXCIsXHJcbn0pID0+IHtcclxuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XHJcbiAgICAgIHdlYmdsOiAyLFxyXG4gICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICBkcHI6IE1hdGgubWluKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDIpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleFRvUmdiKGNvbG9yMSk7XHJcbiAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIDEpO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGdsLmNhbnZhcyBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xyXG4gICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuXHJcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUcmlhbmdsZShnbCk7XHJcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHtcclxuICAgICAgdmVydGV4LFxyXG4gICAgICBmcmFnbWVudCxcclxuICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxyXG4gICAgICAgIGlSZXNvbHV0aW9uOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxXSkgfSxcclxuICAgICAgICB1VGltZVNwZWVkOiB7IHZhbHVlOiB0aW1lU3BlZWQgfSxcclxuICAgICAgICB1Q29sb3JCYWxhbmNlOiB7IHZhbHVlOiBjb2xvckJhbGFuY2UgfSxcclxuICAgICAgICB1V2FycFN0cmVuZ3RoOiB7IHZhbHVlOiB3YXJwU3RyZW5ndGggfSxcclxuICAgICAgICB1V2FycEZyZXF1ZW5jeTogeyB2YWx1ZTogd2FycEZyZXF1ZW5jeSB9LFxyXG4gICAgICAgIHVXYXJwU3BlZWQ6IHsgdmFsdWU6IHdhcnBTcGVlZCB9LFxyXG4gICAgICAgIHVXYXJwQW1wbGl0dWRlOiB7IHZhbHVlOiB3YXJwQW1wbGl0dWRlIH0sXHJcbiAgICAgICAgdUJsZW5kQW5nbGU6IHsgdmFsdWU6IGJsZW5kQW5nbGUgfSxcclxuICAgICAgICB1QmxlbmRTb2Z0bmVzczogeyB2YWx1ZTogYmxlbmRTb2Z0bmVzcyB9LFxyXG4gICAgICAgIHVSb3RhdGlvbkFtb3VudDogeyB2YWx1ZTogcm90YXRpb25BbW91bnQgfSxcclxuICAgICAgICB1Tm9pc2VTY2FsZTogeyB2YWx1ZTogbm9pc2VTY2FsZSB9LFxyXG4gICAgICAgIHVHcmFpbkFtb3VudDogeyB2YWx1ZTogZ3JhaW5BbW91bnQgfSxcclxuICAgICAgICB1R3JhaW5TY2FsZTogeyB2YWx1ZTogZ3JhaW5TY2FsZSB9LFxyXG4gICAgICAgIHVHcmFpbkFuaW1hdGVkOiB7IHZhbHVlOiBncmFpbkFuaW1hdGVkID8gMS4wIDogMC4wIH0sXHJcbiAgICAgICAgdUNvbnRyYXN0OiB7IHZhbHVlOiBjb250cmFzdCB9LFxyXG4gICAgICAgIHVHYW1tYTogeyB2YWx1ZTogZ2FtbWEgfSxcclxuICAgICAgICB1U2F0dXJhdGlvbjogeyB2YWx1ZTogc2F0dXJhdGlvbiB9LFxyXG4gICAgICAgIHVDZW50ZXJPZmZzZXQ6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoW2NlbnRlclgsIGNlbnRlclldKSB9LFxyXG4gICAgICAgIHVab29tOiB7IHZhbHVlOiB6b29tIH0sXHJcbiAgICAgICAgdUNvbG9yMTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShoZXhUb1JnYihjb2xvcjEpKSB9LFxyXG4gICAgICAgIHVDb2xvcjI6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoaGV4VG9SZ2IoY29sb3IyKSkgfSxcclxuICAgICAgICB1Q29sb3IzOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KGhleFRvUmdiKGNvbG9yMykpIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2wsIHsgZ2VvbWV0cnksIHByb2dyYW0gfSk7XHJcblxyXG4gICAgY29uc3Qgc2V0U2l6ZSA9ICgpID0+IHtcclxuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlY3Qud2lkdGgpKTtcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZWN0LmhlaWdodCkpO1xyXG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBjb25zdCByZXMgPSAocHJvZ3JhbS51bmlmb3Jtcy5pUmVzb2x1dGlvbiBhcyB7IHZhbHVlOiBGbG9hdDMyQXJyYXkgfSkudmFsdWU7XHJcbiAgICAgIHJlc1swXSA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcclxuICAgICAgcmVzWzFdID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoc2V0U2l6ZSk7XHJcbiAgICByby5vYnNlcnZlKGNvbnRhaW5lcik7XHJcbiAgICBzZXRTaXplKCk7XHJcblxyXG4gICAgbGV0IHJhZiA9IDA7XHJcbiAgICBjb25zdCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgY29uc3QgbG9vcCA9ICh0OiBudW1iZXIpID0+IHtcclxuICAgICAgKHByb2dyYW0udW5pZm9ybXMuaVRpbWUgYXMgeyB2YWx1ZTogbnVtYmVyIH0pLnZhbHVlID0gKHQgLSB0MCkgKiAwLjAwMTtcclxuICAgICAgcmVuZGVyZXIucmVuZGVyKHsgc2NlbmU6IG1lc2ggfSk7XHJcbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcclxuICAgIH07XHJcbiAgICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcclxuICAgICAgcm8uZGlzY29ubmVjdCgpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjYW52YXMpO1xyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICAvLyBJZ25vcmVcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbXHJcbiAgICB0aW1lU3BlZWQsXHJcbiAgICBjb2xvckJhbGFuY2UsXHJcbiAgICB3YXJwU3RyZW5ndGgsXHJcbiAgICB3YXJwRnJlcXVlbmN5LFxyXG4gICAgd2FycFNwZWVkLFxyXG4gICAgd2FycEFtcGxpdHVkZSxcclxuICAgIGJsZW5kQW5nbGUsXHJcbiAgICBibGVuZFNvZnRuZXNzLFxyXG4gICAgcm90YXRpb25BbW91bnQsXHJcbiAgICBub2lzZVNjYWxlLFxyXG4gICAgZ3JhaW5BbW91bnQsXHJcbiAgICBncmFpblNjYWxlLFxyXG4gICAgZ3JhaW5BbmltYXRlZCxcclxuICAgIGNvbnRyYXN0LFxyXG4gICAgZ2FtbWEsXHJcbiAgICBzYXR1cmF0aW9uLFxyXG4gICAgY2VudGVyWCxcclxuICAgIGNlbnRlclksXHJcbiAgICB6b29tLFxyXG4gICAgY29sb3IxLFxyXG4gICAgY29sb3IyLFxyXG4gICAgY29sb3IzLFxyXG4gIF0pO1xyXG5cclxuICByZXR1cm4gPGRpdiByZWY9e2NvbnRhaW5lclJlZn0gY2xhc3NOYW1lPXtgZ3JhaW5pZW50LWNvbnRhaW5lciAke2NsYXNzTmFtZX1gLnRyaW0oKX0gLz47XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmFpbmllbnQ7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIlJlbmRlcmVyIiwiUHJvZ3JhbSIsIk1lc2giLCJUcmlhbmdsZSIsImhleFRvUmdiIiwiaGV4IiwicmVzdWx0IiwiZXhlYyIsInBhcnNlSW50IiwidmVydGV4IiwiZnJhZ21lbnQiLCJHcmFpbmllbnQiLCJ0aW1lU3BlZWQiLCJjb2xvckJhbGFuY2UiLCJ3YXJwU3RyZW5ndGgiLCJ3YXJwRnJlcXVlbmN5Iiwid2FycFNwZWVkIiwid2FycEFtcGxpdHVkZSIsImJsZW5kQW5nbGUiLCJibGVuZFNvZnRuZXNzIiwicm90YXRpb25BbW91bnQiLCJub2lzZVNjYWxlIiwiZ3JhaW5BbW91bnQiLCJncmFpblNjYWxlIiwiZ3JhaW5BbmltYXRlZCIsImNvbnRyYXN0IiwiZ2FtbWEiLCJzYXR1cmF0aW9uIiwiY2VudGVyWCIsImNlbnRlclkiLCJ6b29tIiwiY29sb3IxIiwiY29sb3IyIiwiY29sb3IzIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyUmVmIiwiY3VycmVudCIsInJlbmRlcmVyIiwid2ViZ2wiLCJhbHBoYSIsImFudGlhbGlhcyIsImRwciIsIk1hdGgiLCJtaW4iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiZ2wiLCJyIiwiZyIsImIiLCJjbGVhckNvbG9yIiwiY2FudmFzIiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImRpc3BsYXkiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsImdlb21ldHJ5IiwicHJvZ3JhbSIsInVuaWZvcm1zIiwiaVRpbWUiLCJ2YWx1ZSIsImlSZXNvbHV0aW9uIiwiRmxvYXQzMkFycmF5IiwidVRpbWVTcGVlZCIsInVDb2xvckJhbGFuY2UiLCJ1V2FycFN0cmVuZ3RoIiwidVdhcnBGcmVxdWVuY3kiLCJ1V2FycFNwZWVkIiwidVdhcnBBbXBsaXR1ZGUiLCJ1QmxlbmRBbmdsZSIsInVCbGVuZFNvZnRuZXNzIiwidVJvdGF0aW9uQW1vdW50IiwidU5vaXNlU2NhbGUiLCJ1R3JhaW5BbW91bnQiLCJ1R3JhaW5TY2FsZSIsInVHcmFpbkFuaW1hdGVkIiwidUNvbnRyYXN0IiwidUdhbW1hIiwidVNhdHVyYXRpb24iLCJ1Q2VudGVyT2Zmc2V0IiwidVpvb20iLCJ1Q29sb3IxIiwidUNvbG9yMiIsInVDb2xvcjMiLCJtZXNoIiwic2V0U2l6ZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJtYXgiLCJmbG9vciIsInJlcyIsImRyYXdpbmdCdWZmZXJXaWR0aCIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJybyIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInJhZiIsInQwIiwicGVyZm9ybWFuY2UiLCJub3ciLCJsb29wIiwidCIsInJlbmRlciIsInNjZW5lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkaXNjb25uZWN0IiwicmVtb3ZlQ2hpbGQiLCJkaXYiLCJyZWYiLCJ0cmltIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Grainient.tsx\n"));

/***/ })

});